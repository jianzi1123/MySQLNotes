### 第09章 性能分析工具的使用

在数据库调优中，我们的目标就是  `响应时间更快，吞吐量更大`。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式 

#### 1.数据库服务器的优化步骤

当我们遇到[数据库调优](https://so.csdn.net/so/search?q=数据库调优&spm=1001.2101.3001.7020)问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。

整个流程划分成了` 观察（Show status）` 和 `行动（Action）` 两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动

![1771d1ef972c4fbd946c55b1fb52d0e7](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/1771d1ef972c4fbd946c55b1fb52d0e7.png)

![618f6a951d8e45473f8c5dc91185180f](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/618f6a951d8e45473f8c5dc91185180f.png)

![2344459cacd61a3a4d7f4aef4a3c9b69](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/2344459cacd61a3a4d7f4aef4a3c9b69.png)

可以看到数据库调优的步骤中越往金字塔尖走，其成本越高，效果越差，因此我们在数据库调优的过程中，要重点把握金字塔底部的 sql 及索引调优，数据库表结构调优，系统配置参数调优等软件层面的调优

#### 2.查看系统的性能参数

可以使用show status语句查询一些数据库服务器的**性能参数和使用频率**。

一些常用的性能参数如下：

•Connections：连接MySQL服务器的次数。
•Uptime：MySQL服务器的上线时间。
•Slow_queries：慢查询的次数。
•Innodb_rows_read：Select查询返回的行数
•Innodb_rows_inserted：执行INSERT操作插入的行数
•Innodb_rows_updated：执行UPDATE操作更新的行数
•Innodb_rows_deleted：执行DELETE操作删除的行数
•Com_select：查询操作的次数。
•Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。
•Com_update：更新操作的次数。
•Com_delete：删除操作的次数

- 若查询MySQL服务器的连接次数，则可以执行如下语句：

  ```mysql
  mysql> show status like 'connections';
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | Connections   | 8     |
  +---------------+-------+
  1 row in set (0.02 sec)
  ```

- 若查询服务器工作时间，则可以执行如下语句：

  ```mysql
  mysql> show status like 'uptime';
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | Uptime        | 3901  |
  +---------------+-------+
  1 row in set (0.00 sec)
  ```

- 若查询MySQL服务器的慢查询次数，则可以执行如下语句：

  ```mysql
  mysql> SHOW STATUS LIKE 'Slow_queries';
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | Slow_queries  | 0     |
  +---------------+-------+
  1 row in set (0.00 sec)
  ```

  注：慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行 `表结构优化` 或者`查询语句优化`

- 查看存储引擎增删改查的行数，则可以执行如下语句：

  ```mysql
  mysql> show status like 'innodb_rows_%';
  +----------------------+----------+
  | Variable_name        | Value    |
  +----------------------+----------+
  | Innodb_rows_deleted  | 0        |
  | Innodb_rows_inserted | 1000902  |
  | Innodb_rows_read     | 37011100 |
  | Innodb_rows_updated  | 0        |
  +----------------------+----------+
  4 rows in set (0.00 sec)
  ```

  

#### **3.** **统计SQL的查询成本：last_query_cost**

![a4241b17ff5659823e4c5ce6e8adf251](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/a4241b17ff5659823e4c5ce6e8adf251.png)

```mysql
SHOW STATUS LIKE 'last_query_cost';
```

```mysql
mysql> select * from student_info where id=900001;
+--------+------------+--------+-----------+----------+---------------------+
| id     | student_id | name   | course_id | class_id | create_time         |
+--------+------------+--------+-----------+----------+---------------------+
| 900001 |      32727 | UXgOBo |     10068 |    10129 | 2024-04-01 18:35:17 |
+--------+------------+--------+-----------+----------+---------------------+
1 row in set (0.00 sec)

mysql> show status like 'last_query_cost';
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| Last_query_cost | 1.000000 |  #这里的1代表页数
+-----------------+----------+
1 row in set (0.00 sec)

mysql> select * from student_info where student_id=199900;
+--------+------------+--------+-----------+----------+---------------------+
| id     | student_id | name   | course_id | class_id | create_time         |
+--------+------------+--------+-----------+----------+---------------------+
| 350159 |     199900 | ZWKJrJ |     10034 |    10000 | 2024-04-01 18:34:59 |
| 631168 |     199900 | mjlDhb |     10087 |    10184 | 2024-04-01 18:35:08 |
| 656281 |     199900 | zxPFJD |     10039 |    10167 | 2024-04-01 18:35:09 |
| 685395 |     199900 | AEvneI |     10049 |    10099 | 2024-04-01 18:35:10 |
+--------+------------+--------+-----------+----------+---------------------+
4 rows in set (0.23 sec)

mysql> show status like 'last_query_cost';
+-----------------+---------------+
| Variable_name   | Value         |
+-----------------+---------------+
| Last_query_cost | 100512.649000 |
+-----------------+---------------+
1 row in set (0.00 sec)

mysql> select * from student_info where student_id=199000;
+--------+------------+--------+-----------+----------+---------------------+
| id     | student_id | name   | course_id | class_id | create_time         |
+--------+------------+--------+-----------+----------+---------------------+
| 164483 |     199000 | evQROr |     10072 |    10127 | 2024-04-01 18:34:53 |
| 365712 |     199000 | HntgwQ |     10018 |    10021 | 2024-04-01 18:34:59 |
| 529283 |     199000 | ZWJImj |     10067 |    10200 | 2024-04-01 18:35:05 |
| 592403 |     199000 | sQaDRw |     10090 |    10108 | 2024-04-01 18:35:07 |
| 681580 |     199000 | wkKSlB |     10041 |    10170 | 2024-04-01 18:35:10 |
+--------+------------+--------+-----------+----------+---------------------+
5 rows in set (0.20 sec)

```

不知道大家有没有发现，上面的查询页的数量是刚才的 10倍，但是查询的效率并没有明显的变化，就是因为采用了**顺序读取**的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量（`last_query_cost`）增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。

使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。

> SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：
>
> 1. `位置决定效率`。如果页就在数据库`缓冲池`中，那么效率是最高的，否则还需要从`内存`或者`磁盘`中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。==即 数据库缓冲池>内存>磁盘==
> 2. `批量决定效率`。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。==即顺序读取>大于随机读取==
>
> 所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到`缓冲池`中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。



#### **4.** **定位执行慢的SQL：慢查询日志**(==没听明白==)

MySQL的慢查询日志，用来记录在MySQL中`响应时间超过阈值`的语句，具体指运行时间超过`long_query_time`的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为`10`，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。

默认情况下，MySQL数据库`没有开启慢查询日志`，需要我们手动来设置这个参数。`如果不是调优需要的话，一般不建议启动该参数`，因为开启慢查询日志会或多或少带来一定的性能影响。

##### **4.1** **开启慢查询日志参数**

**1.** **开启slow_query_log**

```mysql
set global slow_query_log='ON';
```

查看下慢查询日志是否开启，以及慢查询日志文件的位置：

```mysql
show variables like `%slow_query_log%`;
```

**2.** **修改long_query_time阈值**

```mysql
show variables like '%long_query_time%';
```

```mysql
#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 
mysql > set global long_query_time = 1; 
mysql> show global variables like '%long_query_time%'; 

mysql> set long_query_time=1; 
mysql> show variables like '%long_query_time%';
```

![51771021b4ad2f3850697f73979f7176](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/51771021b4ad2f3850697f73979f7176.png)

##### **4.2** **查看慢查询数目**

```mysql
SHOW GLOBAL STATUS LIKE '%Slow_queries%';
```

##### 4.3 案例演示

创建表

```mysql
CREATE TABLE `student` (
    `id` INT(11) NOT NULL AUTO_INCREMENT,
    `stuno` INT NOT NULL ,
    `name` VARCHAR(20) DEFAULT NULL,
    `age` INT(3) DEFAULT NULL,
    `classId` INT(11) DEFAULT NULL,
    PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

```

创建函数

```mysql
set global log_bin_trust_function_creators=1;   # 不加global只是当前窗口有效

DELIMITER //
CREATE FUNCTION rand_string(n INT)
RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
DECLARE chars_str VARCHAR(100) DEFAULT
'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
DECLARE return_str VARCHAR(255) DEFAULT '';
DECLARE i INT DEFAULT 0;
WHILE i < n DO
   SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
   SET i = i + 1;
  END WHILE;
  RETURN return_str;
END //
DELIMITER ;
#测试
SELECT rand_string(10);

```

产生随机数值

```mysql
DELIMITER //
CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN 
DECLARE i INT DEFAULT 0; 
SET i = FLOOR(from_num +RAND()*(to_num - from_num+1))  ;
RETURN i; 
END //
DELIMITER ;
#测试：
SELECT rand_num(10,100);

```

创建存储过程

```mysql
DELIMITER //
CREATE PROCEDURE insert_stu1(  START INT , max_num INT )
BEGIN 
DECLARE i INT DEFAULT 0; 
SET autocommit = 0;   #设置手动提交事务
REPEAT  #循环
SET i = i + 1;  #赋值
INSERT INTO student (stuno, NAME ,age ,classId ) VALUES
((START+i),rand_string(6),rand_num(10,100),rand_num(10,1000)); 
UNTIL i = max_num 
END REPEAT; 
COMMIT;  #提交事务
END //
DELIMITER ;
```

调用存储过程

```mysql
#调用刚刚写好的函数, 4000000条记录,从100001号开始
mysql> CALL insert_stu1(100001,4000000);

```

注意，这个时间会比较长，请耐心等待几分钟哟。结束后可以查询下是不是插入成功了。

```mysql
mysql> select count(*) from student;
+----------+
| count(*) |
+----------+
|  4000000 |
+----------+
1 row in set (0.82 sec)

```

##### 4.4 测试及说明

**1. 执行一下下面的查询操作，进行慢查询语句的测试**

```mysql
# 注意：此时long_query_time已经设置为1了哦~
mysql> SELECT * FROM student WHERE stuno = 3455655;
+---------+---------+--------+------+---------+
| id      | stuno   | name   | age  | classId |
+---------+---------+--------+------+---------+
| 3355654 | 3455655 | ZfCwDz |   76 |     228 |
+---------+---------+--------+------+---------+
1 row in set (1.03 sec)

mysql> SELECT * FROM student WHERE name = 'ZfCwDz';
+---------+---------+--------+------+---------+
| id      | stuno   | name   | age  | classId |
+---------+---------+--------+------+---------+
|   32843 |  132844 | zfcWDZ |   32 |     304 |
|  889126 |  989127 | ZfCwDz |   77 |     249 |
| 2015535 | 2115536 | zfcWDZ |   36 |     459 |
| 3176527 | 3276528 | ZFcwdZ |   81 |     941 |
| 3355654 | 3455655 | ZfCwDz |   76 |     228 |
+---------+---------+--------+------+---------+
5 rows in set (1.09 sec)

```

从上面的结果可以看出来，查询学生编号合和姓名花费时间 都在1s以上。已经达到了秒的数量级，说明目前查询效率是非常低的，下面我们分析一下原因:

**2. 先查看下慢查询的记录**

```mysql
mysql> show status like 'slow_queries';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Slow_queries  | 2     |
+---------------+-------+
1 row in set (0.01 sec)

```

> 🎯补充说明：
>
> 在Mysql中，除了上述变量，控制慢查询日志的还有另外一个变量 min_examined_row_limit 。这个变量的意思是，查询扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过 long_query_time 的值，那么这个查询就被记录到慢查询日志中。反之，则不被记录到慢查询日志中。另外，min_examined_row_limit 默认是 0，我们也一般不会去修改它。
>
>     mysql> SHOW VARIABLES like 'min%';
>     +------------------------+-------+
>     | Variable_name          | Value |
>     +------------------------+-------+
>     | min_examined_row_limit | 0     |
>     +------------------------+-------+
>     1 row in set (0.02 sec)
>
> 当这个值为默认值0时，与 long_query_time=10合在一起，表示只要查询的执行时间超过10秒钟，哪怕一个记录也没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改"my.ini"文件，来修改查询时长，或者通过SET指令，用SQL语句修改min_examined_row_limit 的值。
> 
>



##### **4.3**5 **慢查询日志分析工具：mysqldumpslow**

```shell
#得到返回记录集最多的10个SQL 
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log 
#得到访问次数最多的10个SQL 
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log
#得到按照时间排序的前10条里面含有左连接的查询语句 
mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/atguigu-slow.log 
#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况 
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more
```

![ff77e4fe5a137f3e0e984dfed2d24a10](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/ff77e4fe5a137f3e0e984dfed2d24a10.png)

mysqldumpslow 命令的具体参数如下：

    -a: 不将数字抽象成N，字符串抽象成S
    -s: 是表示按照何种方式排序：
        c: 访问次数
        l: 锁定时间
        r: 返回记录
        t: 查询时间
        al:平均锁定时间
        ar:平均返回记录数
        at:平均查询时间 （默认方式）
        ac:平均查询次数
    -t: 即为返回前面多少条的数据；
    -g: 后边搭配一个正则匹配模式，大小写不敏感的；
接下来我们可以找到慢查询日志的位置:

![188dc7f9814dd009bc01d26143986532](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/188dc7f9814dd009bc01d26143986532.png)

举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：

```mysql
[root@hadoop102 mysql]# mysqldumpslow -s t -t 5 /var/lib/mysql/hadoop102-slow.log 

Reading mysql slow query log from /var/lib/mysql/hadoop102-slow.log
Count: 1  Time=283.29s (283s)  Lock=0.00s (0s)  Rows=0.0 (0), root[root]@hadoop102
  CALL insert_stu1(N,N)

Count: 1  Time=1.09s (1s)  Lock=0.00s (0s)  Rows=5.0 (5), root[root]@localhost
  SELECT * FROM student WHERE name = 'S'

Count: 1  Time=1.03s (1s)  Lock=0.00s (0s)  Rows=1.0 (1), root[root]@localhost
  SELECT * FROM student WHERE stuno = N

Died at /usr/bin/mysqldumpslow line 162, <> chunk 3.

```

##### **4.5** **关闭慢查询日志**

**方式1：永久性方式**

```ini
[mysqld] 
slow_query_log=OFF
#或
[mysqld] 
#slow_query_log =OFF
```

**方式2：临时性方式**

```mysql
SET GLOBAL slow_query_log=off;
```

##### 4.6 删除与恢复慢查询日志

调优结束可以及时删除慢查询日志节省磁盘空间哟，当然手工删除也是可以的

![0e43bfc76b2ffd873a3e881e7c8fac6f](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/0e43bfc76b2ffd873a3e881e7c8fac6f.png)

如果误删了，而且还没有了备份，可以使用下面的命令来重新恢复生成哟，执行完毕后会在数据目录下重新生成查询日志文件

```mysql
#先要打开慢查询日志
SET GLOBAL slow_query_log=ON;
#恢复慢查询日志
mysqladmin -uroot -p flush-logs slow
```

>提示

> 慢查询日志都是使用`mysqladmin -uroot -p flush-logs slow` 命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在于新的日志文件中，如果需要旧的查询日志，就必须事先备份。









#### **5.** **查看** **SQL** **执行成本：SHOW PROFILE**

```mysql
show variables like 'profiling';
#开启
set profiling = 'ON';
#查看
show profiles;
show profile cpu,block io for query 2;
```

🔊 show profile的常用查询参数：

① ALL：显示所有的开销信息。
② BLOCK IO：显示块 IO 开销。
③ CONTEXT SWITCHES：上下文切换开销。
④ CPU：显示 CPU 开销信息。
⑤ IPC：显示发送和接收开销信息。
⑥ MEMORY：显示内存开销信息。
⑦ PAGE FAULTS：显示页面错误开销信息。
⑧ SOURCE：显示和 Source_function，Source_file，Source_line 相关的开销信息。
⑨ SWAPS：显示交换次数开销信息。

> `SHOW PROFILE` 命令将被弃用，不过我们可以从 `information_schema` 中的 `profiling` 数据表进行查看



#### **6.** **分析查询语句：EXPLAIN**（内容太多了，我没仔细看）

![0f20ee3121dfd0daee25ee3ba1db8b43](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/0f20ee3121dfd0daee25ee3ba1db8b43.png)



##### **6.1** **基本语法**

```mysql
EXPLAIN SELECT select_options 
#或者
DESCRIBE SELECT select_options
```

如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个EXPLAIN ，就像这样：

```mysql
mysql> EXPLAIN SELECT 1;
```

![9a5762c760918391af90e5a10af5c529](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/9a5762c760918391af90e5a10af5c529.png)

![7e286d10ad9a06464f4911aa5505bb79](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/7e286d10ad9a06464f4911aa5505bb79.png)

**EXPLAIN 语句输出的各个列的作用如下：**

| 列名          | 描述                                                     |
| ------------- | -------------------------------------------------------- |
| id            | 在一个大的查询语句中每个SELECT关键字都对应一个`唯一的id` |
| select_type   | SELECT关键字对应的那个查询的类型                         |
| table         | 表名                                                     |
| partitions    | 匹配的分区信息                                           |
| type          | 针对单表的访问方法                                       |
| possible_keys | 可能用到的索引                                           |
| key           | 实际上使用的索引                                         |
| key_len       | 实际使用到的索引长度                                     |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息   |
| rows          | 预估的需要读取的记录条数                                 |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比             |
| Extra         | 一些额外的信息                                           |

##### **6.2 EXPLAIN各列作用**

**1. table**

不论我们的查询语句有多复杂，包含了多少个表 ，到最后也是需要对每个表进行`单表访问`的，所以MySQL规定**EXPLAIN语句输出的每条记录都对应着某个单表的访问方法**，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）。

```mysql
#查询的每一行记录都对应着一个单表
EXPLAIN SELECT * FROM s1;

# s1：驱动表 s2:被驱动表
EXPLAIN SELECT * FROM s1 INNER JOIN s2;
```

如下图，一张表对应一个记录。

![7422bfdc6cf19b57ded5f4254ee65e35](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/7422bfdc6cf19b57ded5f4254ee65e35.png)

**2. id**

实际上，在查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id ，代表着一次查询。这个id 就是 `EXPLAIN`语句的第一列。

- **id如果相同，可以认为是一组，从上往下顺序执行**
- **在所有组中，id值越大，优先级越高，越先执行**
- **关注点：id号每个号码，表示一趟独立的查询,一个sql的查询趟数越少越好**

**3. select_type**

![6399b387426312a0db573048fbc61a69](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/6399b387426312a0db573048fbc61a69.png)

**4. partitions**

==5. type（重点）==

![7c4a44543222a55b2b32b0f6bdbe7e80](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/7c4a44543222a55b2b32b0f6bdbe7e80.png)

**1️⃣system**

当表中只有一条记录，并且该表中存储引擎统计数据是精确的，比如 MYISAM，Memory，那么其访问方法就是`System`。这种方式几乎是性能最高的，当然我们几乎用不上。

![5a16dae8a7ed78b4c964cc5e0a090ab1](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/5a16dae8a7ed78b4c964cc5e0a090ab1.png)

但凡我们再插入一条数据，其访问方式就变成了性能最差的全表扫描 `ALL`。

![62fdaf009f7df3825af794fa7f08e940](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/62fdaf009f7df3825af794fa7f08e940.png)

如果存储引擎是InnoDB，即使只有一条数据，其访问方式也是ALL，这是因为 InnnoDB 访问数据不是精确的

![7795326f2fbf062b3f780738d090513a](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/7795326f2fbf062b3f780738d090513a.png)

**2️⃣Const**

当我们根据主键或者唯一的二级索引，与常数进行等值匹配时，对单表的访问方法就是 `const`。这个访问方式的效率低于 `system`，但也是很高效的

比如对主键与常数匹配，进行等值查询

```mysql
EXPLAIN SELECT * FROM s1 WHERE id = 10005;
```

![abd6b80cf9af83f23f96405ba7a508ce](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/abd6b80cf9af83f23f96405ba7a508ce.png)

**3️⃣eq_ref**

再进行**连接查询**时，如果**被驱动表**是通过主键或者唯一二级索引等值匹配的方式进行查询的，那么被驱动表的访问方式是 `eq_ref`。这也是一种性能很不错的方式。

```mysql
EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
```

上面连接查询语句，对于驱动表来说，就是对s1全表进行扫描，找到符合条件的数据，因此其`type`是`All`,对被驱动表来说，相于直接访问驱动表查询到的数据进行等值查询，因此其访问方式是`eq_ref`

![463fd44a01a106555515b733dd924b90](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/463fd44a01a106555515b733dd924b90.png)



9️⃣index

当我们可以使用索引覆盖，但是需要扫描的全部的索引记录时，该表的访问方式就是 index。索引覆盖后面文章介绍优化器时会详细介绍，为了便于大家理解，先简单介绍如下。比如下面 sql 语句中，key_part2 ，key_part2 都属于联合索引 idx_key_part(key_part1, key_part2, key_part3) 的一部分，在查找数据时可以用上这个联合索引，而不用进行回表操作，这种情况即索引覆盖

```mysql
EXPLAIN SELECT key_part2 FROM s1 WHERE key_part2 = 'a';
```

![cd850a3f00131c5bf7a465d85ccf6fee](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/cd850a3f00131c5bf7a465d85ccf6fee.png)

小结：

**结果值从最好到最坏依次是：** **system > const > eq_ref > ref** **> fulltext > ref_or_null > index_merge > unique_subquery > index_subquery >** **range > index > ALL** 

==SQL性能优化的目标：至少要达到 range级别，要求是ref级别，最好是consts级别。==（阿里巴巴开发手册要求）

**6. possible_keys和key**

**7. key_len（重点）**

**key_len的长度计算公式：**

```
varchar(10)变长字段且允许NULL = 10 * ( character set： utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段) 

varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)

char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL) 

char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)
```

**8. ref** 

当索引列进行等值查询时，与索引列匹配的对象信息。

**9. rows（重点）**

预估的需要读取的记录条目数，条目数越小越好。这是因为值越小，加载I/O的页数就越少~

```
EXPLAIN SELECT * FROM s1 WHERE key1 > 'z';
```

![8e6c3310d2274c233a39b5cbcff0faea](./%E7%AC%AC09%E7%AB%A0%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8.assets/8e6c3310d2274c233a39b5cbcff0faea.png)

**10. filtered**



**11. Extra**

顾名思义，`Extra `列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来`更准确的理解MySQL到底将如何执行给定的查询语句`。MySQL提供的额外信息有好几十个，我们就不一一介绍了，所以我们只挑比较重要的额外信息介绍给大家。





#### **5. EXPLAIN的进一步使用**

##### **5.1 EXPLAIN四种输出格式**

这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：`传统格式`，`JSON格式`，`TREE格式`以及`可视化输出`。用户可以根据需要选择适用于自己的格式。

**1.** **传统格式**

**2. JSON格式** 

JSON格式：在EXPLAIN单词和真正的查询语句中间加上`FORMAT=JSON`。用于查看执行成本`cost_info`

**3. TREE格式**

TREE格式是8.0.16版本之后引入的新格式，主要根据查询的`各个部分之间的关系`和`各部分的执行顺序`来描述如何查询。

**4.** **可视化输出**

可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。

##### **5.2 SHOW WARNINGS的使用** 

```mysql
mysql> EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;
# 查看优化后的执行语句
mysql> SHOW WARNINGS\G
```

#### **6.** **分析优化器执行计划：trace**

```mysql
# 开启
SET optimizer_trace="enabled=on",end_markers_in_json=on; 
# 设置大小
set optimizer_trace_max_mem_size=1000000;
# 使用
select * from student where id < 10;
select * from information_schema.optimizer_trace\G
```

#### **7. MySQL监控分析视图-sys schema** 

**7.1 Sys schema视图使用场景**

**索引情况**

```mysql
#1. 查询冗余索引 
select * from sys.schema_redundant_indexes; 
#2. 查询未使用过的索引 
select * from sys.schema_unused_indexes; 
#3. 查询索引的使用情况 
select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema='dbname' ;
```

**表相关**

```mysql
# 1. 查询表的访问量 
select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from sys.schema_table_statistics group by table_schema,table_name order by io desc; 
# 2. 查询占用bufferpool较多的表 
select object_schema,object_name,allocated,data
from sys.innodb_buffer_stats_by_table order by allocated limit 10; 
# 3. 查看表的全表扫描情况 
select * from sys.statements_with_full_table_scans where db='dbname';
```

**语句相关**

```mysql
#1. 监控SQL执行的频率 
select db,exec_count,query from sys.statement_analysis order by exec_count desc; 
#2. 监控使用了排序的SQL 
select db,exec_count,first_seen,last_seen,query
from sys.statements_with_sorting limit 1; 
#3. 监控使用了临时表或者磁盘临时表的SQL 
select db,exec_count,tmp_tables,tmp_disk_tables,query
from sys.statement_analysis where tmp_tables>0 or tmp_disk_tables >0 order by (tmp_tables+tmp_disk_tables) desc;
```

**IO相关**

```mysql
#1. 查看消耗磁盘IO的文件 
select file,avg_read,avg_write,avg_read+avg_write as avg_io
from sys.io_global_by_file_by_bytes order by avg_read limit 10;
```

**Innodb** **相关**

```mysql
#1. 行锁阻塞情况 
select * from sys.innodb_lock_waits;
```

### 